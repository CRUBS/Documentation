
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4.5.1. Introduction &#8212; Documentation Doc Outil Crubs 1.0.0</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="next" title="4.6. Amelioration du LIDAR" href="Tree-Lidar.html" />
    <link rel="prev" title="4.5. Motorisation" href="Tree-Motorisation.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="introduction">
<h1><span class="section-number">4.5.1. </span>Introduction<a class="headerlink" href="#introduction" title="Lien permanent vers ce titre">¶</a></h1>
<p>Ici se trouve le code pour l’asservissement en vitesse des moteurs DC du robot. L’asservissement est géré par un dsPIC33EP256MC502 et est programmé via l’IDE MPLAB X.</p>
<a class="reference internal image-reference" href="../_images/1.png"><img alt="../_images/1.png" class="align-center" src="../_images/1.png" style="width: 225.0px; height: 225.0px;" /></a>
<a class="reference internal image-reference" href="../_images/2.png"><img alt="../_images/2.png" class="align-center" src="../_images/2.png" style="width: 272.0px; height: 185.0px;" /></a>
<p>L’objectif de l’asservissement est de s’assurer que la vitesse de rotation du moteur sera bien celle qui est attendu. Pour cela, la présence d’un encodeur est nécessaire afin d’avoir un retour quant à la vitesse de rotation du moteur puis adapter la consigne de tension pour atteindre la vitesse de rotation attendue. Le moteur sera contrôlé par un <a class="reference external" href="https://www.sparkfun.com/datasheets/Robotics/L298_H_Bridge.pdf">pont en H L298N</a>.</p>
<p>L’asservissement est réalisé avec un moteur DC allant à 156 tours/min en sortie de réducteur et à 6450 tours/min avant réducteur. L’encodeur utilisé est un encodeur incrémental 12 points. Vous pouvez trouver à <a class="reference external" href="https://www.posital.com/fr/produits/interface-de-communication/incremental/incremental-encoder.php">ce lien</a> une explication du fonctionnement d’un encodeur. Il est à noter que notre encodeur ne possède pas de signal zéro (ou home).</p>
</div>
<div class="section" id="creation-du-pid">
<h1><span class="section-number">4.5.2. </span>Création du PID<a class="headerlink" href="#creation-du-pid" title="Lien permanent vers ce titre">¶</a></h1>
<p>L’objectif de cet asservissement est d’avoir un système stable avec un dépassement nul ou quasi-nul, aucun dépassement statique et un temps de réponse le plus faible possible mais inférieur à 200 ms.</p>
<p>Afin de répondre à ces exigences nous avons mis en place un PID (Proportional Integral Derivator) doté de 3 facteur kp, ki et kd. Leur impact sur l’asservissement est décrit ci-dessous pour plus d’information veuillez visiter <a class="reference external" href="http://www.ferdinandpiette.com/blog/2011/08/implementer-un-pid-sans-faire-de-calculs/">ce second lien</a>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>L&#39;erreur statique, c&#39;est l&#39;erreur finale une fois que le système est stabilité. Cette erreur doit être nulle. Pour diminuer l&#39;erreur statique, il faut augmenter Kp et Ki.
Le dépassement, c&#39;est le rapport entre le premier pic et la consigne. Ce dépassement diminue si Kp ou Ki diminuent ou si Kd augmente.
Le temps de montée correspond au temps qu&#39;il faut pour arriver ou dépasser à la consigne. Le temps de montée diminue si Kp ou Ki augmentent ou si Kd diminue.
Le temps de stabilisation, c&#39;est le temps qu&#39;il faut pour que le signal commette une erreur inférieure à 5% de la consigne. Ce temps de stabilisation diminue quand Kp et Ki augmentent.
</pre></div>
</div>
<p>Afin de pré-dimensionner ces valeurs nous avons simulé le système sur Scilab ce qui nous a donné kp=100, ki=2 et kd=2.</p>
<p>Afin de pouvoir faire cela nous avons dû identifier le comportment du moteur pour cela nous avons mis en entrée une tension de 12V et print la vitesse renvoyé par l’encodeur toutes les 20 ms. À partir de là, nous avons déterminé le gain K et le temps de réponse Tau du moteur. Nous avons supposé que le moteur se comportait comme un premier ordre car avec notre résolution de valeur la différence n’est pas détectable.</p>
<p>Ensuite nous avons appliqué ces variables au moteur et les avons ajustées à tatons afin d’obtenir le comportement souhaité ce qui nous a donné kp=10, ki=20 et kd=0.3. En conclusion, la simulation par Scilab n’est pas nécessaire si la stabilité du système lors des essais n’est pas obligatoire.</p>
</div>
<div class="section" id="programmation-du-pic">
<h1><span class="section-number">4.5.3. </span>Programmation du PIC<a class="headerlink" href="#programmation-du-pic" title="Lien permanent vers ce titre">¶</a></h1>
<p>Le PID pour l’asservissement du moteur a été réalisé théoriquement. Il faut désormais programmer le PIC.</p>
<p>Pour cela, nous allons utiliser l’IDE <a class="reference external" href="https://www.microchip.com/en-us/tools-resources/develop/mplab-x-ide">MPLAB X</a>, qui est spécialement développé pour la programmation des PICs.</p>
<p>Nous allons voir comment ont été programmés les différents éléments afin d’asservir le moteur ainsi que de communiquer avec d’autres contrôleurs via bus CAN. Pour toute cette partie, il sera nécessaire de se référer à la <a class="reference external" href="https://ww1.microchip.com/downloads/aemDocuments/documents/MCU16/ProductDocuments/DataSheets/dsPIC33EPXXXGP50X-dsPIC33EPXXXMC20X-50X-and-PIC24EPXXXGP-MC20X-Family-Data-Sheet-DS70000657J.pdf">documentation du PIC</a> ainsi qu’aux documentations des différents modules.</p>
<p>Pour programmer le PIC, il faut aussi installer le compilateur. Pour un dsPIC33, il nous faut le compilateur 16 bits <a class="reference external" href="https://www.microchip.com/en-us/tools-resources/develop/mplab-xc-compilers">XC16</a>.</p>
<div class="section" id="generation-d-une-pwm">
<h2><span class="section-number">4.5.3.1. </span>Génération d’une PWM<a class="headerlink" href="#generation-d-une-pwm" title="Lien permanent vers ce titre">¶</a></h2>
<p>Nous allons commencer par voir comment a été paramétrée la PWM sur le PIC.</p>
<p>La première étape est de démarrer MCC, qui est une interface graphique pour aider à la configuration des registres. Pour démarrer MCC, il suffit de cliquer sur Tools dans la barre des menus puis Embedded et enfin MPLAB Code Configurator. Lors du premier démarrage il vous sera demandé de choisir un type de contenu, choisissez MCC classic. Ensuite cliquez sur Finish. Le lancement de MCC prend ensuite un certain temps.</p>
<p>Finalement, vous devriez avoir une interface ressemblant à celle ci-dessous. Avec la zone centrale où l’on va réaliser le paramétrage, le panneau à droite où le PIC est représenté avec ses différents périphériques. En bas se trouve la zone que nous utiliserons pour sélectionner les différents pins et à gauche, nous avons un panneau nous permettant de sélectionner différents modules.</p>
<a class="reference internal image-reference" href="../_images/3.png"><img alt="../_images/3.png" class="align-center" src="../_images/3.png" style="width: 940.0px; height: 573.0px;" /></a>
<p>Nous allons maintenant configurer le système pour notre utilisation. Pour cela, nous allons nous rendre dans le System Module puis configurer comme montré sur l’image ci-dessous. Nous choisissons l’oscillateur interne au PIC et mettons le postscaler à 1:1.</p>
<a class="reference internal image-reference" href="../_images/4.png"><img alt="../_images/4.png" class="align-center" src="../_images/4.png" style="width: 400.0px; height: 429.0px;" /></a>
<p>Nous passons maintenant dans l’onglet Registers du System Module afin de procéder à un paramétrage plus fin pour permettre le fonctionnement de la PWM et du module QEI. Il faut régler les registres définis ci-dessous sous peine de non fonctionnement de la PWM.</p>
<a class="reference internal image-reference" href="../_images/5.png"><img alt="../_images/5.png" class="align-center" src="../_images/5.png" style="width: 400.0px; height: 407.0px;" /></a>
<a class="reference internal image-reference" href="../_images/6.png"><img alt="../_images/6.png" class="align-center" src="../_images/6.png" style="width: 400.0px; height: 455.0px;" /></a>
<p>Il serait possible théoriquement possible d’utiliser le module PWM de MCC, mais je ne suis jamais parvenu à faire fonctionner la PWM depuis le module. Nous allons donc configurer la PWM manuellement.</p>
<p>Tout d’abord il faut définir le pin de PWM. En se référent à la doc, les pins RB10 à RB15 peuvent être utilisés pour générer une PWM. Nous allons utiliser le pin RB15. Il faut définir le pin en tant que sortie. Pour cela, se rendre dans le Pin Manager: Grid View en bas de l’écran. Dans la section Pin Module, sélectionner le pin 15 du port B en tant que sortie, la case doit devenir verte.</p>
<p>Dans la section Clock, il est possible de désactiver le pin CLKO car il ne va pas nous servir.</p>
<p>Les pins activés s’affichent aussi dans le Pin Manager: Package View à droite.</p>
<p>Cliquez sur le bouton Generate en haut à gauche pour générer le code comme configuré précédemment.</p>
<p>Un fichier main.c a été généré et nous allons le modifier pour faire fonctionner la PWM. Se référer à la <a class="reference external" href="https://ww1.microchip.com/downloads/en/DeviceDoc/dsPIC33-PIC24-FRM-High-Speed-PWM-DS70000645.pdf">documentation PWM</a> pour plus de détails quant au paramétrage.</p>
<p>Nous allons créer une fonction init_PWM pour initialiser la PWM. Cette fonction sera à appeler dans le main et la PWM fonctionnera. Nous définissons une PWM à 2 kHz avec un rapport cyclique de 50 %.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Initialisation of the PWM</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">init_PWM</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/* Set PWM Period on Primary Time Base */</span>
    <span class="n">PTPER</span> <span class="o">=</span> <span class="mi">3684</span><span class="p">;</span> <span class="c1">// 500 us</span>

    <span class="cm">/* Set Phase Shift */</span>
    <span class="n">PHASE1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Set Duty Cycles */</span>
    <span class="n">MDC</span> <span class="o">=</span> <span class="mi">1842</span><span class="p">;</span> <span class="c1">// 50 %</span>

    <span class="cm">/* Set Dead Time Values */</span>
    <span class="n">DTR1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ALTDTR1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Set PWM Mode to Push-Pull, swap for having a &#39;high&#39; duty cycle</span>
<span class="cm">     * and enable only pwm1 on pin RB15</span>
<span class="cm">     */</span>
    <span class="n">IOCON1</span> <span class="o">=</span> <span class="mh">0x4C02</span><span class="p">;</span>

    <span class="cm">/* Set PWM Mode to Independent */</span>
    <span class="n">PWMCON1</span> <span class="o">=</span>  <span class="mh">0x0100</span><span class="p">;</span>

    <span class="cm">/* Configure Faults */</span>
    <span class="n">FCLCON1</span> <span class="o">=</span> <span class="mh">0x0003</span><span class="p">;</span>

    <span class="cm">/* 1:1 Prescaler */</span>
    <span class="n">PTCON2</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>

    <span class="c1">// Enable only pwm on pin RB15</span>
    <span class="n">IOCON2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">IOCON3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Enable PWM Module */</span>
    <span class="n">PTCON</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La valeur à mettre dans le registre PTPER pour choisir la période de la PWM se fait avec la formule suivante :</p>
<a class="reference internal image-reference" href="../_images/7.png"><img alt="../_images/7.png" class="align-center" src="../_images/7.png" style="width: 673.0px; height: 182.0px;" /></a>
<p>Nous allons aussi définir une fonction set_duty_cycle pour modifier le rapport cyclique de la PWM.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Set the duty cycle of the PWM</span>
<span class="cm"> * @param duty: wanted duty cycle of the pwm</span>
<span class="cm"> * 0 &lt;= duty &lt;=1</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_duty_cycle</span><span class="p">(</span><span class="kt">float</span> <span class="n">duty</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// duty must be between 0 and 1</span>
    <span class="k">if</span><span class="p">(</span><span class="n">duty</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">duty</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">duty</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">duty</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

    <span class="c1">// MDC = Duty cycle register</span>
    <span class="c1">// PTPER = Period register</span>
    <span class="n">MDC</span> <span class="o">=</span> <span class="n">PTPER</span> <span class="o">*</span> <span class="n">duty</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Pour définir le sens de rotation du moteur, nous allons définir deux pins en tant que sortie dans le Pin Manager. Nous choisissons les pins RB12 et RB13. Dans le Pin Module, nous allons mettre l’un des deux pin en valeur haute au démarrage en cochant la case. Une fois le code généré, nous nous rendons dans le fichier main et créons une fonction pour définir le sens de rotation du moteur.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Set the rotating direction of the motor</span>
<span class="cm"> * @param clockwise: set the rotating direction of the motor clockwise</span>
<span class="cm"> * The rotating direction set here may not be really it depending how the motor is cabled</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_rotation_clockwise</span><span class="p">(</span><span class="kt">bool</span> <span class="n">clockwise</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Set or reset RB12 and RB13</span>
    <span class="n">LATBbits</span><span class="p">.</span><span class="n">LATB12</span> <span class="o">=</span> <span class="n">clockwise</span><span class="p">;</span>
    <span class="n">LATBbits</span><span class="p">.</span><span class="n">LATB13</span> <span class="o">=</span> <span class="o">!</span><span class="n">clockwise</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="lecture-de-l-encodeur">
<h2><span class="section-number">4.5.3.2. </span>Lecture de l’encodeur<a class="headerlink" href="#lecture-de-l-encodeur" title="Lien permanent vers ce titre">¶</a></h2>
<p>La PWM est maintenant générée et nous pouvons donc contrôler le moteur à différentes vitesses. Nous allons voir comment lire la vitesse de rotation du moteur à partir de l’encodeur. Pour cela, un <a class="reference external" href="https://ww1.microchip.com/downloads/en/DeviceDoc/70000601c.pdf">module QEI</a> (Quadrature Encoder Interface) est disponible sur les dsPIC, mais ne peut pas être défini depuis MCC.</p>
<p>Nous commençons par définir, dans le Pin Manager, les pins QEA et QEB sur les pins RB10 et RB11 en tant qu’entrées. Ces pins ont été choisis car ils sont tolérant jusqu’à 5 V et notre encodeur renvoie une tension de 5 V. Une fois le code généré, nous nous rendons dans le fichier main et créons une fonction pour initialiser le module QEI.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Initilisation of the QEI</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">init_QEI</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RPINR14</span> <span class="o">=</span> <span class="mh">0x2a2b</span><span class="p">;</span> <span class="c1">// Set QEI on RB10 and RB11 (pins 21 and 22)</span>

    <span class="c1">// Set parameters</span>
    <span class="n">QEI1CONbits</span><span class="p">.</span><span class="n">CCM</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Counter Control Mode Selection bits set as x4 mode</span>
    <span class="n">QEI1CONbits</span><span class="p">.</span><span class="n">INTDIV</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="c1">// Timer clock prescaler set as 1:128</span>
    <span class="n">QEI1CONbits</span><span class="p">.</span><span class="n">IMV</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Index match value</span>
    <span class="n">QEI1IOCbits</span><span class="p">.</span><span class="n">FLTREN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Deactivate filter</span>
    <span class="n">QEI1CONbits</span><span class="p">.</span><span class="n">PIMOD</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Position counter is unaffected by the Index input</span>
    <span class="n">QEI1IOCbits</span><span class="p">.</span><span class="n">SWPAB</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Don&#39;t swap QEA and QEB</span>
    <span class="n">QEI1CONbits</span><span class="p">.</span><span class="n">QEIEN</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Enable QEI module</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Une fois la fonction exécutée, la lecture de la vitesse de rotation du moteur sera réalisée. La variable POS1CNTL sera incrémentée à chaque impulsion de l’encodeur. Le traitement sera vu dans la partie Utilisation des timers.</p>
</div>
<div class="section" id="utilisation-des-timers">
<h2><span class="section-number">4.5.3.3. </span>Utilisation des timers<a class="headerlink" href="#utilisation-des-timers" title="Lien permanent vers ce titre">¶</a></h2>
<p>Nous allons paramétrer un premier timer qui lèvera une interruption toutes les 12 ms afin de procéder à l’asservissement en fonction de la vitesse de rotation du moteur durant les 12 dernières millisecondes. Pour configurer le timer, nous allons utiliser MCC où depuis la fenêtre Device Resources, nous ajoutons le timer1. Le paramétrage est montré dans l’image suivante :</p>
<a class="reference internal image-reference" href="../_images/8.png"><img alt="../_images/8.png" class="align-center" src="../_images/8.png" style="width: 600.0px; height: 302.0px;" /></a>
<p>Une fois le code générer, nous modifions le fichier main. Voici le code à ajouter :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;mcc_generated_files/tmr1.h&quot;</span><span class="cp"></span>

<span class="c1">// 12 = nb points coder ; 4 because the QEI mode is x4 ; angle in radians = 0.1309</span>
<span class="cp">#define ANGLE_CODER 360.0 / 12.0 / 4.0 * 3.1415926535897932384626433 / 180</span>
<span class="cp">#define TIME_INTERVAL 0.01 </span><span class="c1">// s</span>

<span class="c1">// 0.01 == time between 2 calls of the timer interrupt</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">rotating_speed_coef</span> <span class="o">=</span> <span class="n">ANGLE_CODER</span> <span class="o">/</span> <span class="n">TIME_INTERVAL</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">old_position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Previous position of the encoder</span>

<span class="c1">// PID variables</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">kp</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">ki</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">kd</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span> <span class="c1">// Coef PID</span>
<span class="k">volatile</span> <span class="kt">int</span> <span class="n">previous_error</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">integral</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">int</span> <span class="n">rotating_speed_target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// rad/s</span>

<span class="cm">/*</span>
<span class="cm"> * Callback function called by the timer1 interrupts each 12 ms</span>
<span class="cm"> * for calculating the rotating speed of the motor</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">speed_rotation_measure</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">IFS0bits</span><span class="p">.</span><span class="n">T1IF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// Clear timer 1 interrupt flag</span>

    <span class="kt">int</span> <span class="n">current_position</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">POS1CNTL</span><span class="p">;</span> <span class="c1">// Get the pulse count</span>

    <span class="c1">// Calculate the rotating speed in rad/s ;</span>
    <span class="c1">// Around 700 rad/s at max speed</span>
    <span class="kt">int</span> <span class="n">rotating_speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_position</span> <span class="o">-</span> <span class="n">old_position</span><span class="p">)</span> <span class="o">*</span> <span class="n">rotating_speed_coef</span><span class="p">;</span>

    <span class="n">old_position</span> <span class="o">=</span> <span class="n">current_position</span><span class="p">;</span>

    <span class="n">speed_count</span> <span class="o">+=</span> <span class="n">rotating_speed</span><span class="p">;</span>
    <span class="n">speed_measure_count</span> <span class="o">++</span><span class="p">;</span>

    <span class="n">control_motor_speed</span><span class="p">(</span><span class="n">rotating_speed</span><span class="p">,</span> <span class="n">TIME_INTERVAL</span><span class="p">);</span> <span class="c1">// Enslave</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En définissant aussi les fonctions set_rotating_speed_target et control_motor_speed :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Enslave the motor to rotate at the speed defined by rotating_speed_target</span>
<span class="cm"> * depending on the current speed</span>
<span class="cm"> * @param speed: current rotating speed of the motor in rad/s</span>
<span class="cm"> * @param time_interval: time between two controls</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">control_motor_speed</span><span class="p">(</span><span class="kt">int</span> <span class="n">speed</span><span class="p">,</span> <span class="kt">float</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Calculate the error between the target speed and current speed</span>
    <span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">rotating_speed_target</span> <span class="o">-</span> <span class="n">speed</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rotating_speed_target</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>

    <span class="c1">// Calculate the proportional term</span>
    <span class="kt">int</span> <span class="n">proportional</span> <span class="o">=</span> <span class="n">kp</span> <span class="o">*</span> <span class="n">error</span><span class="p">;</span>

    <span class="c1">// Calculate the integral term</span>
    <span class="n">integral</span> <span class="o">+=</span> <span class="n">ki</span> <span class="o">*</span> <span class="n">error</span> <span class="o">*</span> <span class="n">time_interval</span><span class="p">;</span>

    <span class="c1">// Calculate the derivative term</span>
    <span class="kt">float</span> <span class="n">derivative</span> <span class="o">=</span> <span class="n">kd</span> <span class="o">*</span> <span class="p">(</span><span class="n">error</span> <span class="o">-</span> <span class="n">previous_error</span><span class="p">)</span> <span class="o">/</span> <span class="n">time_interval</span><span class="p">;</span>

    <span class="c1">// Change the rotating speed</span>
    <span class="n">set_duty_cycle</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span> <span class="p">(</span><span class="n">proportional</span> <span class="o">+</span> <span class="n">integral</span> <span class="o">+</span> <span class="n">derivative</span><span class="p">)</span> <span class="o">/</span> <span class="mf">670.0</span><span class="p">);</span>

    <span class="n">previous_error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span> <span class="c1">// Update the error</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the rotating speed target of the motor.</span>
<span class="cm"> * @param target: wanted rotating speed of the motor,</span>
<span class="cm"> * if &lt;0, the motor rotate in the other direction</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_rotating_speed_target</span><span class="p">(</span><span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">rotating_speed_target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>

    <span class="c1">// Set rotating direction</span>
    <span class="n">set_rotation_clockwise</span><span class="p">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Reset</span>
    <span class="n">integral</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">previous_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Il n’y a plus qu’à ajouter les lignes suivantes dans le main afin de lancer l’asservissement du moteur à la vitesse demandée :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">TMR1_SetInterruptHandler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">speed_rotation_measure</span><span class="p">);</span>
<span class="n">set_rotating_speed_target</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>
<span class="n">TMR1_Start</span><span class="p">();</span>
</pre></div>
</div>
<p>En rentrant une valeur négative en paramètre de la fonction set_rotating_speed, le moteur sera asservi pour tourner dans l’autre sens.</p>
</div>
<div class="section" id="utilisation-du-bus-i2c">
<h2><span class="section-number">4.5.3.4. </span>Utilisation du bus I2C<a class="headerlink" href="#utilisation-du-bus-i2c" title="Lien permanent vers ce titre">¶</a></h2>
<p>Afin de communiquer avec la Raspberry Pi, nous utilisons le bus I2C en tant qu’esclave. Il est possible d’utiliser MCC pour la configuration, elle est assez facile (penser à cocher la case clock stretching). Cependant, nous allons refaire l’API de l’I2C pour qu’elle corresponde plus à l’utilisation. L’API est fortement inspirée de celle proposée par MCC mais avec des modifications directement dedans. Les pins pour l’I2C sont limités, nous allons utiliser le RB9 pour SDA et le RB8 pour SCL. Ces pins doivent être configurés en input.</p>
<p>Dans le fichier main.c, nous définissons 2 variables globales. La première qui contient l’adresse I2C que nous définissons pour le PIC (il faut 1 adresse différente par PIC sur le bus) et la deuxième contient un coefficient qui sera explicité un peu plus loin.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">i2c_address</span> <span class="o">=</span> <span class="mh">0x53</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">motor_speed_multiplier</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</pre></div>
</div>
<p>Puis dans la fonction main, nous paramétrons l’I2C :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">I2C1_Initialize</span><span class="p">(</span><span class="n">i2c_address</span><span class="p">,</span> <span class="n">motor_speed_multiplier</span><span class="p">);</span>
<span class="n">I2C1_ReadPointerSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">speed_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speed_measure_count</span><span class="p">);</span>
<span class="n">I2C1_set_receive_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_rotating_speed_target</span><span class="p">);</span>
</pre></div>
</div>
<p>Avec le bus I2C, le PIC reçoit la vitesse de rotation du moteur voulue et envoie la vitesse de rotation réelle. Pour cela, nous communiquons les valeurs sur 1 octet, or la valeur de vitesse peut aller de -700 à 700 rad/s. Nous avons donc décidé que le premier bit correspond au bit de signe (1 = &lt;0, 0 = &gt;= 0) et les 7 bits suivants sont les bits pour la valeur en absolue mais divisée par un facteur pour être inférieur à 128. Ce facteur est définie en fonction de la résolution maximale que peuvent nous donner les encodeurs et qui reste inférieur à 128. Cette valeur est trouvée en divisant l’angle entre 2 pulse de l’encodeur (en rad) par le temps entre les appels de la fonction de mesure de vitesse.</p>
</div>
<div class="section" id="utilisation-de-la-liaison-serie">
<h2><span class="section-number">4.5.3.5. </span>Utilisation de la liaison série<a class="headerlink" href="#utilisation-de-la-liaison-serie" title="Lien permanent vers ce titre">¶</a></h2>
<p>La liaison série n’est pas utilisée dans le code final mais a servi pour le développement. Le paramétrage se fait via MCC en sélectionnant le périphérique UART, et les paramètres de base permette de communiquer. En cochant la bonne case, il est possible d’envoyer un message depuis le PIC en utilisant la fonction printf si la case a été cochée dans MCC. Pour la réception de message, on active les interruptions.</p>
<p>Pour la réception de données, l’interruption est levée pour chaque caractère reçu. Je n’ai pas réussi à faire correctement fonctionner la réception avec l’API proposée par MCC donc la fonction suivante qui doit être appelée à chaque fois qu’un caractère est reçu. On sauvegarde chaque caractère reçu jusqu’au caractère “n” ou que le message dépasse la capacité de la variable où on convertit la string reçue en nombre.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Callback function called when a serial message is received</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">serial_receive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Clear the error if there is one</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">U1STAbits</span><span class="p">.</span><span class="n">OERR</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">U1STAbits</span><span class="p">.</span><span class="n">OERR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">received_char</span> <span class="o">=</span> <span class="n">U1RXREG</span><span class="p">;</span> <span class="c1">// Read the received char</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">received_char</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span> <span class="o">||</span> <span class="n">char_count</span> <span class="o">&gt;=</span> <span class="n">MESSAGE_LEN</span><span class="p">)</span> <span class="c1">// If it is the end of the message</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">message</span><span class="p">);</span> <span class="c1">// Get the integer value</span>
        <span class="k">if</span><span class="p">(</span><span class="n">is_negative</span><span class="p">)</span> <span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">value</span><span class="p">;</span> <span class="c1">// Set the value negative if it necessary</span>

        <span class="n">set_rotating_speed_target</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

        <span class="c1">// Clear the message to be ready for next message</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MESSAGE_LEN</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">message</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;$&#39;</span><span class="p">;</span>
        <span class="n">char_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">is_negative</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">received_char</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="c1">// If the value to be received is negative</span>
        <span class="n">is_negative</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">message</span><span class="p">[</span><span class="n">char_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">received_char</span><span class="p">;</span> <span class="c1">// Store the received character</span>
        <span class="n">char_count</span> <span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La liaison série est désactivée, mais le pin RB6 est prévu RX et le pin RB7 est prévu TX sur la carte moteur.</p>
<p>NOTE : La carte moteur a aussi été prévue pour pouvoir ajouter un quartz en horloge du PIC et d’utiliser le bus CAN avec CRX sur le pin RB9 et CTX sur le pin RB8.</p>
</div>
</div>
<div class="section" id="branchements-du-pic">
<h1><span class="section-number">4.5.4. </span>Branchements du PIC<a class="headerlink" href="#branchements-du-pic" title="Lien permanent vers ce titre">¶</a></h1>
<p>La configuration minimale des branchements du PIC est montrée dans l’image ci-dessous avec les branchements avec le Pickit 3 à gauche. Ce dernier permet de programmer le PIC.</p>
<a class="reference internal image-reference" href="../_images/9.png"><img alt="../_images/9.png" class="align-center" src="../_images/9.png" style="width: 885.0px; height: 352.0px;" /></a>
</div>
<div class="section" id="circuit-electrique">
<h1><span class="section-number">4.5.5. </span>Circuit électrique<a class="headerlink" href="#circuit-electrique" title="Lien permanent vers ce titre">¶</a></h1>
<p>le shemat electrique et le pcb ont ete realiser grace a kicad, les pcb a ete commander chez <a class="reference external" href="https://jlcpcb.com/">JLPPCB</a> et les composants ont ete commander sur <a class="reference external" href="https://www.lcsc.com/">LCSC</a></p>
<ul class="simple">
<li><p><a class="reference internal" href="../CAO/Tree-KiCad.html"><span class="doc">KiCad</span></a></p></li>
</ul>
<div class="section" id="schematique">
<h2><span class="section-number">4.5.5.1. </span>Schématique<a class="headerlink" href="#schematique" title="Lien permanent vers ce titre">¶</a></h2>
</div>
<div class="section" id="pcb">
<h2><span class="section-number">4.5.5.2. </span>PCB<a class="headerlink" href="#pcb" title="Lien permanent vers ce titre">¶</a></h2>
</div>
<div class="section" id="resultat-final">
<h2><span class="section-number">4.5.5.3. </span>Résultat final<a class="headerlink" href="#resultat-final" title="Lien permanent vers ce titre">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Doc Outil Crubs</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Gestion/Tree.html">1. Gestion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Informatique_Programmation/Tree.html">2. Programmation et Informatique</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Robot-2023/Tree.html">3. Robots Coupe de France de Robotique 2023</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Tree.html">4. Robots Coupe de France de Robotique 2024</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Tree-Introduction.html">4.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tree-ArchiRobot.html">4.2. Architecture Robot Principal</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tree-ArchiPAMI.html">4.3. Architecture PAMIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tree-Alimentation.html">4.4. Alimentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="Tree-Motorisation.html">4.5. Motorisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tree-Lidar.html">4.6. Amelioration du LIDAR</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Voron-0.1/Tree.html">5. Imprimante 3D Voron 0.1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CAO/Tree.html">6. CAO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../FAO/Tree.html">7. FAO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Banc-de-test/Tree.html">8. Banc de test portatif</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="Tree.html"><span class="section-number">4. </span>Robots Coupe de France de Robotique 2024</a><ul>
  <li><a href="Tree-Motorisation.html"><span class="section-number">4.5. </span>Motorisation</a><ul>
      <li>Previous: <a href="Tree-Motorisation.html" title="Chapitre précédent"><span class="section-number">4.5. </span>Motorisation</a></li>
      <li>Next: <a href="Tree-Lidar.html" title="Chapitre suivant"><span class="section-number">4.6. </span>Amelioration du LIDAR</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, CRUBS.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/Robot-2024/Motorisation.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>